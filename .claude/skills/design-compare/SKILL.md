---
name: design-compare
description:
  두 디렉토리(또는 파일 세트)의 설계 문서를 비교하여 괴리점을 찾아낸다.
  버전 간 비교(v1 vs v2), 원본 요구사항과 설계 문서 간 정합성 검증에 사용한다.
---

## 사용법

```
/design-compare                              → 기본: docs/design-v2/ 내부 4개 문서 상호 비교
/design-compare docs/design-v1 docs/design-v2  → 두 디렉토리 간 비교
/design-compare file1.md file2.md              → 특정 파일 2개 비교
```

인자가 없으면 `docs/design-v2/` 내부 문서 간 상호 정합성을 검증한다.

## 절차

### 1단계: 파일 수집

- 인자가 디렉토리 2개이면: 각 디렉토리의 `*.md` 파일을 모두 읽는다
- 인자가 파일이면: 해당 파일들을 읽는다
- 인자가 없으면: `docs/design-v2/` 내 4개 문서 + `docs/requirements-analysis.md`를 읽는다
- 읽을 파일이 많으면 **병렬로** 읽는다

### 2단계: 비교 항목별 분석

아래 7개 축으로 문서 간 괴리를 분석한다:

#### A. API 정합성
- URI 경로가 문서 간 일치하는가?
- HTTP 메서드가 일치하는가?
- 쿼리 파라미터 이름/타입이 일치하는가? (예: `startAt` vs `startedAt`)
- 인증 요구 여부가 일치하는가?

#### B. 메서드 네이밍
- 시퀀스 다이어그램의 메서드명과 클래스 다이어그램의 메서드명이 일치하는가?
- Facade/Service/Repository 각 레이어의 메서드가 빠짐없이 존재하는가?

#### C. 필드/컬럼 정합성
- 클래스 다이어그램의 Entity 필드와 ERD 컬럼이 1:1 매핑되는가?
- 타입이 일치하는가? (예: `BigDecimal` ↔ `DECIMAL(19,2)`)
- VO 검증 규칙이 ERD 제약조건과 일치하는가?

#### D. 도메인 규칙 일관성
- 요구사항의 비즈니스 규칙이 시퀀스/클래스에 반영되었는가?
- 예외 흐름(에러 코드, 메시지)이 문서 간 일치하는가?
- Enum 값 목록이 일치하는가?

#### E. 관계/의존성
- ERD의 테이블 관계와 클래스 다이어그램의 의존 관계가 일치하는가?
- Facade → Service 의존 라벨이 완전한가?

#### F. 인덱스/성능
- ERD 인덱스 전략이 주요 조회 패턴(시퀀스)을 커버하는가?
- 반정규화 필드가 클래스 다이어그램에 반영되었는가?

#### G. 네이밍 컨벤션
- camelCase / snake_case 사용이 일관적인가?
- 용어가 유비쿼터스 언어 정의와 일치하는가?

### 3단계: 결과 보고

아래 형식으로 출력한다:

```
## 비교 결과: [소스A] vs [소스B]

### 괴리점 (n건)

| # | 분류 | 파일A 위치 | 파일B 위치 | 내용 | 심각도 |
|---|------|----------|----------|------|-------|
| 1 | API  | req:L110 | seq:L45  | URI 불일치: startAt vs startedAt | HIGH |

### 심각도 기준
- **HIGH**: 구현 시 버그 유발 (API 경로, 메서드명, 필드 불일치)
- **MEDIUM**: 혼동 유발 (네이밍 불일치, 라벨 누락)
- **LOW**: 개선 권장 (문서 구조, 가독성)

### 정합성 체크리스트
- [ ] API URI/파라미터 일치
- [ ] 메서드명 일치 (시퀀스 ↔ 클래스)
- [ ] 필드/컬럼 일치 (클래스 ↔ ERD)
- [ ] 도메인 규칙 반영 완전
- [ ] 의존 관계 라벨 완전
- [ ] 인덱스가 조회 패턴 커버
- [ ] 네이밍 컨벤션 일관
```

## 규칙

- 코드를 수정하지 않는다. 분석과 보고만 수행한다
- 괴리점마다 **어느 쪽이 맞는지 판단하지 않고**, 불일치 사실만 보고한다
- 수정이 필요하면 "어느 문서를 기준으로 통일할지" 선택지를 제시한다
- 파일을 읽을 때는 항상 병렬로 읽는다
