---
name: requirements-analysis
description:
  제공된 요구사항을 분석하고, 개발자와의 질문/대답을 통해 애매한 요구사항을 명확히 하여 정리한다.
  모든 정리가 끝나면, 시퀀스 다이어그램, 클래스 다이어그램, ERD 등을 Mermaid 문법으로 작성한다.
  요구사항이 제공되었을 때, 코드를 작성하기 전 이를 명확히 하는 데에 사용한다.
---

대상: $ARGUMENTS

요구사항을 분석할 때 반드시 다음 흐름을 따른다.

### 1️⃣ 요구사항을 그대로 믿지 말고, 문제 상황으로 다시 설명한다.

- 요구사항 문장을 정리하는 데서 끝내지 않는다.
- "무엇을 만들까?"가 아니라 "지금 어떤 문제가 있고, 그걸 왜 해결하려는가?" 로 재해석한다.
- 다음 관점을 분리해서 정리한다:
    - 사용자 관점
    - 비즈니스 관점
    - 시스템 관점

> 예시
> "상품에 좋아요를 누른다" → "사용자가 관심 상품을 기억하고 재방문할 수 있도록 개인화된 목록을 제공하려는 문제"
> "주문 시 재고를 차감한다" → "동시 주문 상황에서 재고 정합성을 보장하면서 사용자 경험을 해치지 않으려는 문제"

### 2️⃣ 애매한 요구사항을 숨기지 말고 드러낸다

- 추측하거나 알아서 결정하지 않는다.
- 요구사항에서 결정되지 않은 부분을 명시적으로 나열한다.
  **다음 유형의 질문을 반드시 포함한다:**
- 정책 질문: 기준 시점, 성공/실패 조건, 예외 처리 규칙
- 경계 질문: 어디까지가 한 책임인가, 어디서 분리되는가
- 확장 질문: 나중에 바뀔 가능성이 있는가
- 동시성 질문: 동시 요청 시 어떤 동작을 보장해야 하는가

### 3️⃣ 요구사항 명확화를 위한 질문을 개발자 답변이 쉬운 형태로 제시한다

- 질문은 우선순위를 가진다 (중요한 것부터).
- 선택지가 있는 경우, 옵션 + 영향도를 함께 제시한다.

> 형식 예시:
> **Q. 주문 생성과 결제를 하나의 흐름으로 처리할까요?**
> - 선택지 A: 하나의 트랜잭션으로 처리 → 구현 단순, 확장성 낮음
> - 선택지 B: 단계별 분리 (주문 생성 → 결제 요청 → 결제 확인) → 구조 복잡, 보상 처리 유리
> - 선택지 C: 이벤트 기반 비동기 처리 → 가장 복잡, 확장성 최대

### 4️⃣ 합의된 내용을 바탕으로 개념 모델부터 잡는다

- 바로 코드나 기술 얘기로 들어가지 않는다.
- 먼저 다음을 정의한다:
    - 액터 (사용자, 관리자, 외부 시스템)
    - 핵심 도메인 (상품, 브랜드, 좋아요, 주문, 결제 등)
    - 보조/외부 시스템 (결제 게이트웨이 등)
- 유비쿼터스 언어를 정의한다:
    - 한글-영문 매핑 테이블 작성
    - 코드, 문서, API 명세에서 동일하게 사용할 용어 확정
- 이 단계는 "구현"이 아니라 설계 사고 정렬이 목적이다.

### 5️⃣ 다이어그램은 항상 이유 → 다이어그램 → 해석 순서로 제시한다

**다이어그램을 그리기 전에 반드시 설명한다**

- 왜 이 다이어그램이 필요한지
- 이 다이어그램으로 무엇을 검증하려는지

**다이어그램은 각 스킬을 사용하여 작성한다**

각 다이어그램 스킬에 검증 목적이 정의되어 있다. 다음 순서로 실행한다:

1. `/sequence` — 책임 분리, 호출 순서, 트랜잭션 경계를 검증
2. `/class-diagram` — 도메인 책임, 의존 방향, 응집도를 검증
3. `/erd` — 영속성 구조, 관계의 주인, 정규화 여부를 검증

### 6️⃣ 다이어그램을 던지고 끝내지 말고 읽는 법을 짚어준다

- "이 구조에서 특히 봐야 할 포인트"를 2~3줄로 설명한다.
- 설계 의도가 드러나도록 해석을 붙인다.
- 다이어그램 간 정합성은 각 스킬의 정합성 확인 단계에서 검증한다:
    - `/sequence`: 시퀀스의 참여자가 클래스 다이어그램에 존재하는지 확인
    - `/class-diagram`: 시퀀스 참여자와의 정합성 + 클래스 관계가 ERD에 반영되었는지 확인
    - `/erd`: 클래스 다이어그램의 관계가 ERD에 반영되었는지 확인
- 모든 다이어그램 작성 후 `/design-review`로 4개 문서 간 최종 정합성을 확인한다.

### 7️⃣ 설계의 잠재 리스크를 반드시 언급한다

- 현재 설계가 가질 수 있는 위험을 숨기지 않는다.
    - 트랜잭션 비대화
    - 도메인 간 결합도 증가
    - 정책 변경 시 영향 범위 확대
    - 동시성 이슈 (재고 차감, 좋아요 멱등성 등)
    - 외부 시스템 장애 시 보상 처리
- 해결책은 정답처럼 말하지 않고 선택지로 제시한다.

### 톤 & 스타일 가이드

- 강의처럼 설명하지 말고 설계 리뷰 톤을 유지한다
- 정답이라고 제시하기보다, 다른 선택지가 있다면 이를 제공하도록 한다
- 코드보다 의도, 책임, 경계를 더 중요하게 다룬다
- 구현 전에 생각해야 할 것을 끌어내는 데 집중한다

### 산출물 저장 위치

- 요구사항 정리 → `docs/design/01-requirements.md`
- 시퀀스 다이어그램 → `docs/design/02-sequence-diagrams.md`
- 클래스 다이어그램 → `docs/design/03-class-diagram.md`
- ERD → `docs/design/04-erd.md`

### 산출물 구조 (Template)

요구사항 명세서(`01-requirements.md`)는 다음 10개 섹션 구조를 따른다:

```markdown
# 요구사항 명세서

## 1. 문제 정의

(서비스의 핵심 목표 + 각 도메인이 해결하려는 문제를 관점별로 정리)

### 핵심 목표
- (3~5개의 핵심 목표)

### [도메인명]
| 관점 | 문제 |
|------|------|
| 사용자 | ... |
| 비즈니스 | ... |
| 시스템 | ... |

---

## 2. 유비쿼터스 언어

| 한글 | 영문 | 정의 |
|------|------|------|

---

## 3. 액터 정의

| 액터 | 식별 방식 | 권한 및 역할 |
|------|----------|------------|

---

## 4. 유저 시나리오

### 4.1 [기능 그룹명] ([액터])

**사전 조건:** ...

**[기능 설명]:** ...
- 상세 규칙들

**예외 흐름:**
| 조건 | 응답 | 설명 |
|------|------|------|

---

## 5. 도메인 규칙 (Business Rules)

(각 도메인의 상태 전이, 생성/수정/삭제 규칙, 데이터 삭제 정책 등)

---

## 6. API 명세

### 6.1 [API 그룹명]

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|

(쿼리 파라미터, 요청 본문, 필터 조건 상세)

---

## 7. 인증/인가

(인증 방식, 경로별 인증 요구사항 매핑)

---

## 8. 기존 시스템과의 관계

### 기존 완료 (재사용)
- (재사용할 기존 구현물 목록)

### 신규 구현
- (이번에 새로 만들어야 할 것들)

### 추후 확장
- (현재 범위 밖이지만 고려해야 할 것들)

---

## 9. 잠재 리스크

| 리스크 | 영향 | 현재 대응 | 향후 대응 |
|--------|------|----------|----------|

---

## 10. 설계 결정 사항

### [결정 제목]
- (결정 내용과 근거)
```
