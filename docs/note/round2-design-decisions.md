# Round 2 설계 의사결정 기록

2주차 이커머스 도메인(Brand, Product, Like, Order) 설계 시 논의한 트레이드오프와 최종 결정을 정리한다.

---

## 1. 상품 가격 타입

### 선택지

| 선택지             | 장점              | 단점                         |
|-----------------|-----------------|----------------------------|
| **Long (원 단위)** | 단순, 부동소수점 오차 없음 | 외화/할인율 계산 시 유연성 부족         |
| **BigDecimal**  | 정밀 계산 가능, 확장 유연 | 약간의 성능 오버헤드, 비교 시 scale 주의 |

### 최종 결정: BigDecimal, 0 이상

- 원화 커머스라 소수점은 불필요하지만, BigDecimal이 금액 표현의 표준
- 0원 허용 (무료 샘플 등 가능성), 음수 불가

---

## 2. 상품 상태(Status) 관리

### 선택지

| 선택지                            | 장점             | 단점                           |
|--------------------------------|----------------|------------------------------|
| **A: status 없이 stock==0으로 판단** | 단순, 상태 불일치 불가  | 조회 시마다 재고 조건 필요, "미노출" 표현 불가 |
| **B: status 필드 + 재고 연동**       | 명시적, 미노출 기능 지원 | 재고와 상태 간 동기화 필요              |

### 최종 결정: status enum (ON_SALE / SOLD_OUT / HIDDEN) + 재고 연동

- stock 차감 → 0이 되면 → `SOLD_OUT` 자동 전환
- stock 추가 → 0에서 양수가 되면 → `ON_SALE` 자동 복원
- `HIDDEN`은 어드민이 수동으로 설정 (미노출 처리)
- 자동 전환은 동기적으로 처리 (현재 스코프에서 이벤트/비동기 불필요)

---

## 3. 재고 관리 구조 — Product 필드 vs Stock 별도 테이블

### 선택지

| 선택지                       | 장점                       | 단점                      |
|---------------------------|--------------------------|-------------------------|
| **A: Product.stock (VO)** | 단순, join 없음, 검증 캡슐화      | 나중에 분리 시 마이그레이션 필요      |
| **B: Stock 별도 테이블**       | 락 범위 축소, 독립 확장, 캐싱 전략 분리 | 보일러플레이트 증가, 매 조회마다 join |
| **C: Redis 기반 재고**        | 최고 성능, 싱글 스레드 보장         | 인프라 복잡도, 데이터 정합성 관리     |

### Stock 별도 테이블의 구체적 장점

1. **쓰기-쓰기 경합 분리**: 상품 정보 수정(어드민)과 재고 차감(주문)이 서로 다른 행을 락 → 동시 처리 가능. 단, 현실적으로 두 작업이 동시에 일어날 확률은 낮음
2. **독립적 확장**: 창고별 재고 등 다중 재고 모델로 확장 시 Product 테이블 변경 불필요
3. **캐싱 전략 분리**: 상품 정보(거의 불변, 장기 캐싱)와 재고(빈번 변경, 단기 TTL)를 독립적으로 캐싱 가능
4. **이력 관리**: stock_history 같은 변경 추적 테이블 연결이 자연스러움

### VO → 별도 테이블 마이그레이션 비용

크지 않다. 도메인 검증 로직(0 이상, 부족 확인)은 VO든 Entity든 동일하므로, 주요 변경은:

- Stock 엔티티/테이블 생성 + 데이터 이관
- Product에서 stock 필드 제거
- 조회 쿼리에 join 추가
- Service 레이어 분리

### 최종 결정: Product에 stock 필드 + VO로 검증

- 현재 요구사항에 동시성 해결은 포함되지 않음 (향후 과제)
- Redis 기반으로 갈 계획이면 DB 락 범위는 무관
- 테이블 분리의 장점이 현재 규모에서는 실익 없음
- 마이그레이션 비용도 낮으므로 필요 시 분리하면 됨

---

## 4. 좋아요 수 관리 — 실시간 카운트 vs 비정규화

### 선택지

| 선택지                            | 장점           | 단점                    |
|--------------------------------|--------------|-----------------------|
| **A: 매번 COUNT 쿼리**             | 항상 정확, 구현 단순 | likes_desc 정렬 시 성능 저하 |
| **B: Product에 likeCount 비정규화** | 정렬/조회 빠름     | 정합성 관리 필요 (증감 동기화)    |
| **C: Redis 캐시**                | 최고 성능        | 인프라 의존, 캐시-DB 정합성     |

### 최종 결정: Product에 likeCount 비정규화 (향후 Redis 캐시 고려)

- 목록/상세 조회 모두에서 좋아요 수 노출 필요
- likes_desc 정렬이 있으므로 비정규화가 사실상 필수
- 좋아요 등록/취소 시 likeCount 증감 동기 처리
- 대규모 트래픽 시 Redis 전환 검토

---

## 5. 주문 스냅샷 범위

### 선택지

| 선택지                    | 장점           | 단점                      |
|------------------------|--------------|-------------------------|
| **A: 상품명 + 가격만**       | 저장 공간 최소, 단순 | 브랜드 정보 필요 시 join 필요     |
| **B: 상품명 + 가격 + 브랜드명** | 완전한 스냅샷      | 저장 공간 증가, 브랜드명 필요 없을 수도 |

### 최종 결정: 상품명 + 가격만 스냅샷

- 주문 조회 시 브랜드 정보는 불필요
- OrderItem에 productName, productPrice 필드로 저장

---

## 6. 재고 부족 시 주문 정책

### 선택지

| 선택지                           | 장점                | 단점               |
|-------------------------------|-------------------|------------------|
| **A: 전체 실패 (all-or-nothing)** | 단순 명확, 트랜잭션 관리 용이 | UX 불편 (전부 다시 주문) |
| **B: 부분 주문**                  | UX 유리             | 구현 복잡, 사용자 혼란 가능 |

### 최종 결정: 전체 실패

- 재고 부족 상품을 명시하여 에러 응답
- 향후 Redis 재고 선점 구조로 전환 시, 주문 시점에 재고 부족이 발생하는 상황 자체를 최소화

---

## 7. 주문 상태

### 선택지

| 선택지                           | 장점           | 단점             |
|-------------------------------|--------------|----------------|
| **A: 상태 없음 (생성 = 완료)**        | 최소 구현        | 결제 연동 시 대규모 변경 |
| **B: enum 정의만 (CREATED만 사용)** | 확장 대비, 변경 최소 | 약간의 오버헤드       |

### 최종 결정: OrderStatus enum (CREATED, PAID, CANCELLED, FAILED) 정의, 현재는 CREATED만 사용

---

## 8. 브랜드 삭제 전파

### 최종 결정: Cascade Soft Delete

- 브랜드 삭제 시 소속 상품도 soft delete
- 기존 주문의 스냅샷은 유지 (상품명, 가격은 OrderItem에 보존)
- 대고객 조회에서는 삭제된 상품/브랜드 미노출

---

## 9. 좋아요 멱등성

### 멱등성이란?

같은 요청을 여러 번 보내도 결과(서버 상태)가 동일하다는 것.

- `POST /likes` 2번 호출 → 좋아요 1개만 존재, 둘 다 200
- `DELETE /likes` 2번 호출 → 좋아요 삭제 상태 유지, 둘 다 200

### 구현 방식

- DB에 unique constraint (userId + productId)
- 이미 존재하면 early return (200), 중복 생성하지 않음
- 토글 방식은 사용하지 않음 (POST = 등록, DELETE = 취소 명확 분리)

---

## 10. 인증 처리

### 대고객 인증

- `X-Loopers-LoginId` + `X-Loopers-LoginPw` 헤더 기반 식별
- 인증 실패 시 401 응답 (메시지 통일: "인증에 실패했습니다")
- 존재하지 않는 유저 / 비밀번호 불일치를 구분하지 않음 (정보 노출 방지)

### 어드민 인증 (LDAP)

- 실제 LDAP 프로토콜 구현이 아님
- `X-Loopers-Ldap: loopers.admin` 헤더 값 단순 비교
- 인터셉터에서 `/api-admin/**` 경로에 대해 헤더 확인 → 불일치 시 401
- Spring Security 불필요

---

## 11. 기타 결정 사항

| 항목                    | 결정                             |
|-----------------------|--------------------------------|
| 브랜드명 유니크 제약           | 불필요                            |
| 브랜드 parent_id (트리 구조) | 현재 스코프 제외, 필요 시 추가             |
| 브랜드 필드                | name만                          |
| 페이징 응답                | Spring Page 객체 그대로 사용          |
| 주문 날짜 필터              | 선택 파라미터, 기본값 최근 1달, 기준은 주문 생성일 |
| 대고객 vs 어드민 응답 차이      | 어드민은 삭제된 상품/브랜드 조회 가능, 나머지는 동일 |
| 좋아요 목록 응답             | 상품 이름, 가격 포함 (브랜드 제외)          |
| 타인 좋아요 조회             | 불가 (본인 것만)                     |
| 삭제된 상품 좋아요            | 목록에서 미노출, 데이터는 유지              |
| 주문 항목 중복 상품           | 허용 (같은 productId 여러 번 가능)      |
| 주문 항목 수량 제한           | 현재 재고 이하, 향후 1인당 제한 확장 고려      |
