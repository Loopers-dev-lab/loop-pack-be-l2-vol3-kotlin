# 01. 요구사항 분석

---

## 1. 문제 상황 재정의

### 사용자 관점
- 다양한 브랜드의 상품을 둘러보고, 마음에 드는 상품에 좋아요를 누르고, 여러 상품을 한 번에 주문하고 싶다
- 주문 내역을 조회할 때, **당시 구매한 상품 정보(가격, 이름)** 가 그대로 보여야 한다
- 좋아요 한 상품 목록을 모아보고 싶다

### 비즈니스 관점 (1P — 자사몰)
- 자사에서 브랜드와 상품을 직접 관리하는 형태 (입점사/셀러 없음)
- 브랜드와 상품을 관리자(어드민)가 등록/수정/삭제할 수 있어야 한다
- 브랜드 삭제 시 해당 브랜드의 상품도 함께 삭제되어야 한다
- 주문 시 **재고 확인 및 차감**이 보장되어야 한다
- 현재는 장바구니/결제/쿠폰 없이 **주문 즉시 완료** 구조 (추후 확장 가능)

### 시스템 관점
- 동시 주문 시 재고 정합성을 어떻게 보장할 것인가
- 상품 정보가 변경되어도 기존 주문 내역은 보존되어야 한다 (스냅샷)
- 좋아요 데이터는 향후 추천/랭킹의 기초 데이터로 활용될 수 있다

---

## 2. 액터 정의

| 액터 | 인증 방식 | 역할 |
|------|----------|------|
| **비회원** | 없음 | 브랜드 조회, 상품 목록/상세 조회 |
| **회원(User)** | `X-Loopers-LoginId` + `X-Loopers-LoginPw` 헤더 | 좋아요, 주문, 주문 내역 조회 |
| **관리자(Admin)** | `X-Loopers-Ldap: loopers.admin` 헤더 | 브랜드/상품 CRUD, 주문 조회 |

---

## 3. 도메인별 기능 요구사항

### 3.1 브랜드 (Brand)

#### 대고객 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| GET | `/api/v1/brands/{brandId}` | X | 브랜드 정보 조회 |

#### 어드민 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| GET | `/api-admin/v1/brands?page=0&size=20` | LDAP | 브랜드 목록 조회 (페이징) |
| GET | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 상세 조회 |
| POST | `/api-admin/v1/brands` | LDAP | 브랜드 등록 |
| PUT | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 정보 수정 |
| DELETE | `/api-admin/v1/brands/{brandId}` | LDAP | 브랜드 삭제 |

#### 비즈니스 규칙
- 브랜드 삭제 시, 해당 브랜드에 속한 **모든 상품도 함께 삭제**된다
- 브랜드 삭제 시, 삭제되는 상품에 대한 좋아요도 처리가 필요하다

#### 결정이 필요한 사항
> **Q: 브랜드 삭제 = 물리 삭제? Soft Delete?**
> - 주문 이력에 브랜드명이 스냅샷으로 남아있으므로, 브랜드 자체는 Soft Delete(deletedAt)로 처리
> - 대고객 조회 시 삭제된 브랜드는 노출하지 않음
> - BaseEntity의 `delete()` 메서드 활용 (이미 구현됨)

---

### 3.2 상품 (Product)

#### 대고객 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| GET | `/api/v1/products?brandId={brandId}&sort=latest&page=0&size=20` | X | 상품 목록 조회 |
| GET | `/api/v1/products/{productId}` | X | 상품 상세 조회 |

**상품 목록 정렬 옵션:**

| sort | 설명 |
|------|------|
| `latest` | 최신순 (기본값) |
| `price_asc` | 가격 낮은순 |
| `likes_desc` | 좋아요 많은순 |

#### 어드민 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| GET | `/api-admin/v1/products?page=0&size=20&brandId={brandId}` | LDAP | 상품 목록 조회 |
| GET | `/api-admin/v1/products/{productId}` | LDAP | 상품 상세 조회 |
| POST | `/api-admin/v1/products` | LDAP | 상품 등록 |
| PUT | `/api-admin/v1/products/{productId}` | LDAP | 상품 정보 수정 |
| DELETE | `/api-admin/v1/products/{productId}` | LDAP | 상품 삭제 |

#### 비즈니스 규칙
- 상품 등록 시, 브랜드는 **이미 등록된 브랜드**여야 한다 (존재하지 않으면 에러)
- 상품 수정 시, **브랜드는 변경 불가**
- 상품 삭제 시, 해당 상품의 좋아요 데이터 처리 필요
- 재고 수량 관리 필요 (주문 시 차감)
- `likes_desc` 정렬을 위해 좋아요 수 집계가 필요

#### 상품 상태 관리

| 필드 | 타입 | 설명 |
|------|------|------|
| `status` | Enum | `ACTIVE`(판매중), `INACTIVE`(판매중지), `DELETED`(삭제) |
| `displayYn` | Boolean | 전시 여부 (목록에 노출할지) |

> **status와 displayYn을 분리하는 이유:**
> - `status=ACTIVE` + `displayYn=false` → 판매는 가능하지만 목록에는 미노출 (URL 직접 접근 시에만 구매 가능)
> - `status=INACTIVE` → 전시 여부와 무관하게 구매 불가
> - 분리해야 "전시만 숨기고 싶다" vs "판매 자체를 중지하고 싶다"를 독립적으로 제어 가능
>
> **UI 관점 (이렇게도 표현 가능하다):**
> - `displayYn=true` + `ACTIVE` → 일반 상품 카드
> - `displayYn=true` + `INACTIVE` → 딤(dim) 처리 + "판매중지" 뱃지 등으로 표현 가능
> - `displayYn=false` → 목록에서 아예 미노출
> - 두 필드를 분리해야 이런 상태별 시각적 피드백이 가능해지므로 분리 필요
> - 상세 매트릭스는 `05-state-diagrams.md` 참조

#### 결정이 필요한 사항
> **Q: 상품 삭제 시 기존 주문은?**
> - 주문에는 스냅샷이 저장되므로, 상품 삭제가 주문 이력에 영향을 주지 않음
> - 상품도 Soft Delete(deletedAt) 처리

> **Q: 재고가 0이면?**
> - 상품 조회는 가능하되, 주문 시 재고 부족 에러 반환
> - 프론트에서 "품절" 표시를 위해 재고 수량 또는 품절 여부를 응답에 포함

---

### 3.3 좋아요 (Like)

#### 대고객 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| POST | `/api/v1/products/{productId}/likes` | 회원 | 상품 좋아요 등록 |
| DELETE | `/api/v1/products/{productId}/likes` | 회원 | 상품 좋아요 취소 |
| GET | `/api/v1/users/{userId}/likes` | 회원 | 내가 좋아요 한 상품 목록 조회 |

#### 비즈니스 규칙
- 한 사용자가 같은 상품에 **중복 좋아요 불가** (이미 좋아요 상태면 409 CONFLICT 에러)
- 좋아요 취소 시, 이미 취소 상태면 404 NOT_FOUND 에러
- 동시 요청으로 UK 제약 위반 시 `DataIntegrityViolationException` → 409 CONFLICT 변환 (UK가 최종 방어선)
- 상품이 삭제되면, 해당 상품의 좋아요 데이터도 Soft Delete 처리
- 좋아요 수는 상품 목록 정렬(`likes_desc`)에 사용됨

#### 결정이 필요한 사항
> **Q: 좋아요 수 집계 방식?**
> - 선택지 A: 매 조회 시 `COUNT` 쿼리 → 실시간, 하지만 목록 조회 시 성능 이슈
> - 선택지 B: Product에 `likeCount` 컬럼을 두고 좋아요/취소 시 증감 → 빠르지만 정합성 관리 필요
> - **선택: B안** — `likeCount`를 Product에 캐싱. `likes_desc` 정렬 시 매번 COUNT 하면 느림
> - 현재: 동기 처리 (같은 트랜잭션에서 Like 저장 + likeCount 증감)
> - 확장: 이벤트 기반 비동기 처리 + 배치 보정 가능 (트래픽 증가 시)

> **Q: 좋아요 목록 조회 시 삭제된 상품은?**
> - 삭제된 상품(deletedAt != null)은 좋아요 목록에서 제외

---

### 3.4 주문 (Order)

#### 대고객 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| POST | `/api/v1/orders` | 회원 | 주문 요청 |
| GET | `/api/v1/orders?startAt=2026-01-31&endAt=2026-02-10` | 회원 | 유저의 주문 목록 조회 |
| GET | `/api/v1/orders/{orderId}` | 회원 | 단일 주문 상세 조회 |

#### 어드민 API

| METHOD | URI | 인증 | 설명 |
|--------|-----|------|------|
| GET | `/api-admin/v1/orders?page=0&size=20` | LDAP | 주문 목록 조회 |
| GET | `/api-admin/v1/orders/{orderId}` | LDAP | 단일 주문 상세 조회 |

#### 주문 요청 Body

```json
{
  "items": [
    { "productId": 1, "quantity": 2 },
    { "productId": 3, "quantity": 1 }
  ]
}
```

#### 주문 생성 흐름
1. 회원 인증 확인
2. 요청된 상품 목록의 유효성 검증 (상품 존재 여부, 판매 상태, 전시 여부)
3. **재고 확인 및 차감** (동시성 보장)
4. 주문 금액 계산 (현재는 상품 가격 × 수량, 추후 쿠폰/등급 할인 확장)
5. **상품 정보 스냅샷 저장** (당시 가격, 상품명, 브랜드명 등)
6. 주문 생성 (Order + OrderItem)

#### 비즈니스 규칙
- 주문 시 상품 정보를 **스냅샷으로 저장** (상품명, 가격, 브랜드명 등)
- 재고가 부족하면 주문 실패 (어떤 상품의 재고가 부족한지 알려줘야 함)
- 하나의 주문에 여러 상품 포함 가능
- 주문 목록은 **기간별 조회** (`startAt`, `endAt`)
- 다른 사용자의 주문은 조회 불가 (본인 것만)

#### 주문 상태 (현재 과제 범위)

| 상태 | 설명 |
|------|------|
| `ORDERED` | 주문 완료 (현재 과제에서는 주문 즉시 이 상태) |

> 추후 결제/배송이 추가되면 상태 확장:
> `ORDERED` → `PAID` → `SHIPPING` → `DELIVERED` → `CONFIRMED`
> 취소/반품: `CANCELLED`, `RETURNED` 등

#### 스냅샷에 저장할 값

| 필드 | 이유 |
|------|------|
| `productName` | CS 대응, 주문 내역 표시 |
| `productPrice` | 환불 기준가, 정산 |
| `brandName` | 주문 내역 표시 |
| `brandId` | 원본 참조 |
| `productId` | 원본 참조 |

#### 결정이 필요한 사항
> **Q: 재고 동시성 처리?**
> - 선택지 A: 비관적 락 (`SELECT ... FOR UPDATE`)
> - 선택지 B: 낙관적 락 (`@Version` + 재시도)
> - 선택지 C: 분산 락 (Redisson)
> - 선택지 D: DB 원자적 갱신 (`UPDATE SET stock = stock - :qty WHERE stock >= :qty`)
> - **설계 시점에서는 D안 기준으로 설계**, 구현 주차에서 A~D 비교 실험 예정

> **Q: 주문 요청에 productId만 있는데, 가격은?**
> - 가격은 서버에서 상품 테이블을 조회하여 결정 (클라이언트가 가격을 전달하면 위변조 가능)
> - 주문 시점의 상품 가격을 스냅샷으로 저장

---

## 4. 향후 확장 가능 영역 (참고)

> 현재 과제 범위가 아니며, 구현하지 않는다. 구조적으로 확장 여지가 있다는 점만 기록한다.

| 영역 | 한 줄 요약 |
|------|-----------|
| 장바구니 | Cart 테이블 추가, 바로구매/장바구니 통합 |
| 쿠폰/할인 | DiscountPolicy 인터페이스 (전략 패턴) → 구현체 추가만으로 확장 |
| 결제 | PaymentGateway 인터페이스로 결제 수단 추상화 |
| 취소/반품 | OrderItem 단위 상태 관리 + OrderClaim 이력 테이블 |
| 상품 옵션 | OptionGroup/OptionValue/Variant 정규화 구조 |
| 추천/랭킹 | 좋아요(likeCount) 기반 인기 랭킹은 현재 지원. 고급 분석 시 별도 이벤트/집계 테이블 추가 (likes 변경 불필요) |

---

## 5. 유즈케이스 (Use Cases)

### UC-1: 상품 주문

| 항목 | 내용 |
|------|------|
| **액터** | 회원 (User) |
| **사전 조건** | 회원 인증 완료, 1개 이상의 상품이 존재 |
| **사후 조건** | 주문 생성 완료, 재고 차감, 스냅샷 저장 |

**Main Flow**
1. 회원이 주문할 상품과 수량을 전달한다
2. 시스템이 각 상품의 존재 여부, 판매 상태, 전시 여부를 검증한다
3. 시스템이 각 상품의 재고를 차감한다 (DB 원자적 갱신)
4. 시스템이 주문 시점의 상품 정보를 스냅샷으로 저장한다 (ProductSnapshot, PriceSnapshot)
5. 시스템이 주문을 생성하고 주문번호를 발급한다
6. 회원에게 주문 결과를 반환한다

**Alternate Flow**
- 2a. 여러 상품 중 일부만 유효하지 않은 경우 → 해당 상품을 알려주고 주문 실패
- 3a. 재고가 부족한 경우 → 어떤 상품의 재고가 부족한지 알려주고 주문 실패 (이미 차감된 재고는 롤백)

**Exception Flow**
- E1. 인증 실패 → 401 UNAUTHORIZED
- E2. 상품이 존재하지 않음 → 404 NOT_FOUND
- E3. 판매 중지 상품 → 400 BAD_REQUEST "판매 중지된 상품입니다"
- E4. 재고 부족 → 400 BAD_REQUEST "상품의 재고가 부족합니다"

---

### UC-2: 상품 좋아요 등록/취소

| 항목 | 내용 |
|------|------|
| **액터** | 회원 (User) |
| **사전 조건** | 회원 인증 완료, 대상 상품이 존재 |
| **사후 조건** | 좋아요 등록(또는 취소) 완료, Product.likeCount 증감 |

**Main Flow (등록)**
1. 회원이 특정 상품에 좋아요를 요청한다
2. 시스템이 상품 존재 여부를 확인한다
3. 시스템이 해당 회원의 기존 좋아요 여부를 확인한다
4. 좋아요를 저장하고, 상품의 likeCount를 1 증가시킨다

**Main Flow (취소)**
1. 회원이 특정 상품의 좋아요 취소를 요청한다
2. 시스템이 해당 좋아요 레코드를 확인한다
3. 좋아요를 삭제(물리 삭제)하고, 상품의 likeCount를 1 감소시킨다

**Exception Flow (등록)**
- E1. 상품이 존재하지 않음 → 404 NOT_FOUND
- E2. 이미 좋아요한 상품에 재등록 → 409 CONFLICT
- E2-a. 동시 요청으로 UK 제약 위반 → 409 CONFLICT (DB UK가 최종 방어선)

**Exception Flow (취소)**
- E3. 좋아요하지 않은 상품 취소 → 404 NOT_FOUND
- E4. 상품이 이미 삭제된 경우 → 좋아요 레코드 기준으로 처리 (상품 검증 불필요)

---

### UC-3: 브랜드 삭제 (연쇄 삭제)

| 항목 | 내용 |
|------|------|
| **액터** | 관리자 (Admin) |
| **사전 조건** | 관리자 인증 완료 (LDAP), 브랜드가 존재 |
| **사후 조건** | 브랜드 + 소속 상품 + 관련 좋아요 모두 Soft Delete |

**Main Flow**
1. 관리자가 브랜드 삭제를 요청한다
2. 시스템이 브랜드 존재 여부를 확인한다
3. 시스템이 해당 브랜드의 모든 상품을 조회한다
4. 각 상품에 대한 좋아요를 Soft Delete한다
5. 각 상품을 Soft Delete한다
6. 브랜드를 Soft Delete한다

**Alternate Flow**
- 3a. 브랜드에 소속 상품이 없는 경우 → 브랜드만 Soft Delete

**Exception Flow**
- E1. 브랜드가 존재하지 않음 → 404 NOT_FOUND
- E2. 인증 실패 → 401 UNAUTHORIZED

---

### UC-4: 상품 등록

| 항목 | 내용 |
|------|------|
| **액터** | 관리자 (Admin) |
| **사전 조건** | 관리자 인증 완료 (LDAP), 대상 브랜드가 존재 |
| **사후 조건** | 상품 생성 완료 (status=ACTIVE, displayYn=true) |

**Main Flow**
1. 관리자가 브랜드ID, 상품명, 가격, 재고 등의 정보를 전달한다
2. 시스템이 브랜드 존재 여부를 확인한다
3. 시스템이 상품 필드를 검증한다 (이름 공백 불가, 가격 0 이상, 재고 0 이상)
4. 상품을 저장하고 결과를 반환한다

**Exception Flow**
- E1. 존재하지 않는 브랜드ID → 400 BAD_REQUEST "존재하지 않는 브랜드입니다"
- E2. 필드 검증 실패 → 400 BAD_REQUEST (상세 메시지)

---

### UC-5: 주문 내역 조회

| 항목 | 내용 |
|------|------|
| **액터** | 회원 (User) |
| **사전 조건** | 회원 인증 완료 |
| **사후 조건** | 없음 (조회) |

**Main Flow**
1. 회원이 기간(startAt, endAt)을 지정하여 주문 목록을 조회한다
2. 시스템이 해당 회원의 주문만 조회한다 (다른 사용자 주문 접근 불가)
3. 각 주문에 포함된 OrderItem의 스냅샷 정보를 함께 반환한다

**Alternate Flow**
- 1a. 특정 주문 상세 조회 시 → orderId로 단건 조회

**Exception Flow**
- E1. 다른 사용자의 주문 조회 시도 → 403 FORBIDDEN

---

## 6. API 응답 형식

모든 API는 기존 `ApiResponse<T>` 형식을 따른다:

```json
{
  "meta": {
    "result": "SUCCESS",
    "errorCode": null,
    "message": null
  },
  "data": { ... }
}
```

에러 시:
```json
{
  "meta": {
    "result": "FAIL",
    "errorCode": "Bad Request",
    "message": "상품이 존재하지 않습니다."
  },
  "data": null
}
```

---

## 7. 에러 케이스 정리

| 상황 | HTTP Status | ErrorType | 메시지 |
|------|------------|-----------|--------|
| 존재하지 않는 브랜드 조회 | 404 | NOT_FOUND | 존재하지 않는 브랜드입니다 |
| 존재하지 않는 상품 조회 | 404 | NOT_FOUND | 존재하지 않는 상품입니다 |
| 미인증 상태에서 좋아요/주문 | 401 | UNAUTHORIZED | 인증에 실패했습니다 |
| 이미 좋아요 한 상품에 재요청 | 409 | CONFLICT | 이미 좋아요한 상품입니다 |
| 존재하지 않는 브랜드로 상품 등록 | 400 | BAD_REQUEST | 존재하지 않는 브랜드입니다 |
| 상품 수정 시 브랜드 변경 시도 | 400 | BAD_REQUEST | 브랜드는 수정할 수 없습니다 |
| 재고 부족 | 400 | BAD_REQUEST | 상품의 재고가 부족합니다 |
| 판매 중지 상품 주문 | 400 | BAD_REQUEST | 판매 중지된 상품입니다 |
| 삭제된 상품 주문 | 404 | NOT_FOUND | 존재하지 않는 상품입니다 |
| 다른 사용자의 주문 조회 | 403 | FORBIDDEN | 접근 권한이 없습니다 |
