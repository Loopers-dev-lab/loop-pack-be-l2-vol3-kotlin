# 요구사항 명세서

## 1. 문제 정의

이 서비스는 "감성 이커머스"로, 사용자가 좋아하는 브랜드의 상품을 탐색하고, 좋아요를 통해 관심을 표현하며, 여러 상품을 한 번에 주문하는 흐름을 제공한다.

각 도메인이 해결하려는 문제를 관점별로 정리한다.

### 브랜드 & 상품

| 관점   | 문제                                                                                       |
|------|------------------------------------------------------------------------------------------|
| 사용자  | 여러 브랜드의 상품을 탐색하고 비교할 수 있어야 한다. 브랜드별, 가격순, 인기순 등 자신이 원하는 기준으로 상품을 찾을 수 있어야 한다.            |
| 비즈니스 | 브랜드와 상품을 체계적으로 관리하고, 고객에게 노출할 정보와 내부 관리 정보를 분리해야 한다. 브랜드 삭제 시 소속 상품의 생명주기를 함께 관리해야 한다.   |
| 시스템  | 상품 목록 조회는 가장 빈번한 요청이다. 정렬/필터/페이징 조합에서 안정적인 성능을 보장해야 한다. 재고 변경에 따른 상품 상태 전환이 정확히 동작해야 한다. |

### 좋아요

| 관점   | 문제                                                                                             |
|------|------------------------------------------------------------------------------------------------|
| 사용자  | 관심 상품을 기억하고 나중에 재방문할 수 있도록 개인화된 목록이 필요하다. 좋아요를 눌렀는지 여부가 즉시 반영되어야 한다.                           |
| 비즈니스 | 사용자의 관심 데이터는 추후 랭킹, 추천 등 다양한 기능으로 확장될 수 있다. 상품별 좋아요 수는 인기 정렬의 기준이 된다.                          |
| 시스템  | 같은 사용자가 같은 상품에 중복 좋아요를 누르는 것을 방지해야 한다. 좋아요 등록/취소는 멱등하게 동작해야 한다. likeCount 비정규화 시 정합성을 유지해야 한다. |

### 주문

| 관점   | 문제                                                                                 |
|------|------------------------------------------------------------------------------------|
| 사용자  | 여러 상품을 한 번에 담아 주문할 수 있어야 한다. 주문 이력을 기간별로 조회하고, 주문 당시의 상품 정보(이름, 가격)를 확인할 수 있어야 한다. |
| 비즈니스 | 주문 시점의 상품 정보가 스냅샷으로 보존되어야 한다. 상품 가격이 변경되더라도 과거 주문 내역에 영향을 주면 안 된다.                 |
| 시스템  | 주문 시 재고 확인 및 차감이 원자적으로 보장되어야 한다. 동시 주문 상황에서 재고가 음수로 떨어지면 안 된다. (동시성 해결은 향후 과제)     |

---

## 2. 유비쿼터스 언어

도메인 용어를 코드, 문서, API 명세에서 동일하게 사용한다.

| 한글     | 영문              | 정의                                                      |
|--------|-----------------|---------------------------------------------------------|
| 브랜드    | Brand           | 상품을 제공하는 주체. 하나의 브랜드는 여러 상품을 가진다.                       |
| 상품     | Product         | 판매 대상 단위. 반드시 하나의 브랜드에 소속된다.                            |
| 상품 상태  | ProductStatus   | 상품의 판매 상태. ON_SALE(판매중) / SOLD_OUT(재고없음) / HIDDEN(미노출). |
| 재고     | Stock           | 상품의 판매 가능한 수량. VO로 관리하며, 주문 시 차감된다.                     |
| 좋아요    | Like            | 사용자가 상품에 대해 표현하는 관심. 사용자-상품 쌍으로 유일하다.                   |
| 좋아요 수  | LikeCount       | 상품별 좋아요 총 수. Product에 비정규화하여 저장한다.                      |
| 주문     | Order           | 사용자가 하나 이상의 상품을 구매하는 행위.                                |
| 주문 항목  | OrderItem       | 주문에 포함된 개별 상품 단위. 상품 스냅샷과 수량을 가진다.                      |
| 주문 상태  | OrderStatus     | 주문의 진행 상태. CREATED / PAID / CANCELLED / FAILED.         |
| 상품 스냅샷 | ProductSnapshot | 주문 시점의 상품 정보(이름, 가격) 사본. OrderItem에 저장.                 |
| 어드민    | Admin           | 브랜드/상품/주문을 관리하는 내부 운영자. LDAP 헤더로 식별한다.                  |

---

## 3. 액터 정의

| 액터          | 식별 방식                                        | 역할                 |
|-------------|----------------------------------------------|--------------------|
| 사용자 (User)  | `X-Loopers-LoginId` + `X-Loopers-LoginPw` 헤더 | 상품 탐색, 좋아요, 주문     |
| 비로그인 사용자    | 헤더 없음                                        | 상품/브랜드 조회만 가능      |
| 어드민 (Admin) | `X-Loopers-Ldap: loopers.admin` 헤더           | 브랜드/상품 CRUD, 주문 조회 |

> 인증/인가 자체는 구현 범위가 아니며, 헤더 기반 식별만 수행한다.
> 인증 실패 시 401 응답, 메시지는 "인증에 실패했습니다"로 통일한다 (정보 노출 방지).

---

## 4. 유저 시나리오

### 4.1 브랜드 관리 (어드민)

**사전 조건:** 요청 헤더에 `X-Loopers-Ldap: loopers.admin` 포함

**정상 흐름:**

1. 어드민이 브랜드를 등록한다 (name 필수)
2. 어드민이 등록된 브랜드 목록을 페이징하여 조회한다
3. 어드민이 브랜드 정보를 수정한다
4. 어드민이 브랜드를 삭제한다 → 해당 브랜드의 모든 상품도 cascade soft delete

**예외 흐름:**

| 조건                  | 응답  | 설명                          |
|---------------------|-----|-----------------------------|
| LDAP 헤더 누락 또는 값 불일치 | 401 | 어드민 인증 실패                   |
| 브랜드명이 빈 값           | 400 | 필수 필드 누락                    |
| 존재하지 않는 브랜드 수정/삭제   | 404 | soft deleted 포함             |
| 이미 삭제된 브랜드 재삭제      | 200 | 멱등 처리 (BaseEntity.delete()) |

### 4.2 상품 관리 (어드민)

**사전 조건:** 요청 헤더에 `X-Loopers-Ldap: loopers.admin` 포함

**정상 흐름:**

1. 어드민이 특정 브랜드에 상품을 등록한다 (name, price, stock 필수, brandId 지정)
    - 등록 시 기본 status는 `ON_SALE` (stock > 0), `SOLD_OUT` (stock == 0)
2. 어드민이 상품 목록을 조회한다 (페이징, 브랜드 필터, 삭제된 상품 포함)
3. 어드민이 상품 정보를 수정한다 (name, price, stock 변경 가능, 브랜드 변경 불가)
    - stock 변경 시: 0이 되면 status → `SOLD_OUT`, 0에서 양수가 되면 status → `ON_SALE`
    - status를 `HIDDEN`으로 직접 변경 가능
4. 어드민이 상품을 삭제한다 (soft delete)

**예외 흐름:**

| 조건                          | 응답  | 설명               |
|-----------------------------|-----|------------------|
| LDAP 헤더 누락 또는 값 불일치         | 401 | 어드민 인증 실패        |
| 존재하지 않는 브랜드에 상품 등록          | 404 | 삭제된 브랜드 포함       |
| 가격이 음수                      | 400 | price >= 0 제약 위반 |
| 재고가 음수                      | 400 | stock >= 0 제약 위반 |
| 브랜드 변경 시도 (수정 시 brandId 포함) | 400 | 브랜드 변경 불가 정책     |
| 존재하지 않는 상품 수정/삭제            | 404 | soft deleted 포함  |

### 4.3 상품 탐색 (사용자/비로그인)

**사전 조건:** 인증 불필요

**정상 흐름:**

1. 사용자가 상품 목록을 조회한다 (페이징, 정렬, 브랜드 필터)
    - soft deleted 상품 제외, status가 `HIDDEN`인 상품 제외
    - 응답에 좋아요 수(likeCount) 포함
2. 사용자가 특정 상품의 상세 정보를 조회한다
    - 응답에 브랜드 정보, 좋아요 수 포함
3. 사용자가 특정 브랜드의 정보를 조회한다

**정렬 기준:**

| 값            | 설명                       | 기본값 |
|--------------|--------------------------|-----|
| `latest`     | 최신순 (createdAt DESC)     | O   |
| `price_asc`  | 가격 낮은순                   |     |
| `likes_desc` | 좋아요 많은순 (likeCount DESC) |     |

**예외 흐름:**

| 조건                  | 응답  | 설명                              |
|---------------------|-----|---------------------------------|
| 존재하지 않는 상품 조회       | 404 |                                 |
| soft deleted 상품 조회  | 404 | 대고객에서는 삭제된 상품 미노출               |
| HIDDEN 상태 상품 조회     | 404 | 대고객에서는 미노출 상품 접근 불가             |
| 존재하지 않는 브랜드 조회      | 404 |                                 |
| soft deleted 브랜드 조회 | 404 | 대고객에서는 삭제된 브랜드 미노출              |
| 유효하지 않은 sort 값      | 400 | latest, price_asc, likes_desc 외 |

### 4.4 좋아요 (사용자)

**사전 조건:** 요청 헤더에 `X-Loopers-LoginId` + `X-Loopers-LoginPw` 포함 (인증 필수)

**정상 흐름:**

1. 사용자가 상품에 좋아요를 등록한다
    - Product.likeCount 1 증가
2. 사용자가 상품의 좋아요를 취소한다
    - Product.likeCount 1 감소
3. 사용자가 자신이 좋아요한 상품 목록을 조회한다
    - soft deleted 상품은 목록에서 제외
    - 응답에 상품 이름, 가격 포함 (브랜드 제외)

**멱등성 보장:**

- 이미 좋아요한 상품에 다시 POST → 200 응답, 중복 생성하지 않음, likeCount 변경 없음
- 좋아요하지 않은 상품을 DELETE → 200 응답, likeCount 변경 없음

**예외 흐름:**

| 조건                       | 응답  | 설명                      |
|--------------------------|-----|-------------------------|
| 인증 헤더 누락                 | 400 |                         |
| 인증 실패 (유저 없음 / 비밀번호 불일치) | 401 | 메시지 통일                  |
| 존재하지 않는 상품에 좋아요          | 404 |                         |
| soft deleted 상품에 좋아요 등록  | 404 | 삭제된 상품에 좋아요 등록 불가       |
| soft deleted 상품의 좋아요 취소  | 200 | Like 삭제 + likeCount 미갱신 |
| 타인 좋아요 조회                | 400 | @AuthUser로 본인만 조회       |

### 4.5 주문 (사용자)

**사전 조건:** 요청 헤더에 `X-Loopers-LoginId` + `X-Loopers-LoginPw` 포함 (인증 필수)

**정상 흐름:**

1. 사용자가 여러 상품을 수량과 함께 주문 요청한다
2. 시스템이 각 상품의 존재 여부 및 판매 가능 상태를 확인한다
3. 시스템이 각 상품의 재고를 확인하고 차감한다 (all-or-nothing)
    - 재고 차감 후 stock == 0이면 status → `SOLD_OUT` 자동 전환
4. 시스템이 주문 시점의 상품 정보(이름, 가격)를 스냅샷으로 저장한다
5. 주문이 생성되고 (status: CREATED) 사용자에게 응답한다
6. 사용자가 기간별 주문 목록을 조회한다
    - startedAt/endedAt: 선택 파라미터 (LocalDateTime), 미입력 시 최근 1달
    - startedAt: 해당 일시 이상 (>=), endedAt: 해당 일시 미만 (<)
    - 기준: 주문 생성일 (createdAt)
    - 본인의 주문만 조회 가능
7. 사용자가 특정 주문의 상세 정보(주문 항목, 당시 상품 정보)를 조회한다
    - 본인의 주문만 조회 가능

**예외 흐름:**

| 조건                           | 응답  | 설명                        |
|------------------------------|-----|---------------------------|
| 인증 헤더 누락                     | 400 |                           |
| 인증 실패                        | 401 | 메시지 통일                    |
| 주문 항목이 비어있음                  | 400 | items가 null 또는 빈 배열       |
| 주문 항목에 존재하지 않는 상품 포함         | 400 | productId에 해당하는 상품 없음     |
| 주문 항목에 삭제된 상품 포함             | 400 | soft deleted 상품 주문 불가     |
| 주문 항목에 HIDDEN/SOLD_OUT 상품 포함 | 400 | 판매중(ON_SALE)이 아닌 상품 주문 불가 |
| 수량이 0 이하                     | 400 | quantity >= 1             |
| 재고 부족 (1개 상품이라도)             | 400 | 전체 실패, 부족 상품 명시           |
| 타인의 주문 상세 조회                 | 404 | 본인 주문이 아니면 미노출            |

### 4.6 주문 조회 (어드민)

**사전 조건:** 요청 헤더에 `X-Loopers-Ldap: loopers.admin` 포함

**정상 흐름:**

1. 어드민이 전체 주문 목록을 페이징하여 조회한다
2. 어드민이 특정 주문의 상세 정보를 조회한다

**예외 흐름:**

| 조건                  | 응답  | 설명        |
|---------------------|-----|-----------|
| LDAP 헤더 누락 또는 값 불일치 | 401 | 어드민 인증 실패 |
| 존재하지 않는 주문 조회       | 404 |           |

---

## 5. API 명세

### 5.1 브랜드 & 상품 (고객)

| METHOD | URI                            | 인증 | 설명                   |
|--------|--------------------------------|----|----------------------|
| GET    | `/api/v1/brands/{brandId}`     | X  | 브랜드 정보 조회            |
| GET    | `/api/v1/products`             | X  | 상품 목록 조회 (페이징/정렬/필터) |
| GET    | `/api/v1/products/{productId}` | X  | 상품 상세 조회             |

**상품 목록 조회 쿼리 파라미터:**

| 파라미터      | 타입     | 필수 | 기본값      | 설명                                      |
|-----------|--------|----|----------|-----------------------------------------|
| `brandId` | Long   | X  | -        | 브랜드 필터                                  |
| `sort`    | String | X  | `latest` | 정렬: `latest`, `price_asc`, `likes_desc` |
| `page`    | Int    | X  | 0        | 페이지 번호                                  |
| `size`    | Int    | X  | 20       | 페이지당 항목 수                               |

**대고객 조회 필터 조건:**

- `deletedAt IS NULL` (soft deleted 제외)
- `status != HIDDEN` (미노출 제외)

### 5.2 브랜드 & 상품 (어드민)

| METHOD | URI                                                       | 설명                   |
|--------|-----------------------------------------------------------|----------------------|
| GET    | `/api-admin/v1/brands?page=0&size=20`                     | 브랜드 목록 조회 (삭제 포함)    |
| GET    | `/api-admin/v1/brands/{brandId}`                          | 브랜드 상세 조회            |
| POST   | `/api-admin/v1/brands`                                    | 브랜드 등록               |
| PUT    | `/api-admin/v1/brands/{brandId}`                          | 브랜드 수정               |
| DELETE | `/api-admin/v1/brands/{brandId}`                          | 브랜드 삭제 (소속 상품 연쇄 삭제) |
| GET    | `/api-admin/v1/products?page=0&size=20&brandId={brandId}` | 상품 목록 조회 (삭제 포함)     |
| GET    | `/api-admin/v1/products/{productId}`                      | 상품 상세 조회             |
| POST   | `/api-admin/v1/products`                                  | 상품 등록 (브랜드 존재 필수)    |
| PUT    | `/api-admin/v1/products/{productId}`                      | 상품 수정 (브랜드 변경 불가)    |
| DELETE | `/api-admin/v1/products/{productId}`                      | 상품 삭제                |

**어드민 조회 필터 조건:**

- 삭제된 상품/브랜드도 조회 가능 (필터 없음)

### 5.3 좋아요

| METHOD | URI                                  | 인증 | 설명                |
|--------|--------------------------------------|----|-------------------|
| POST   | `/api/v1/products/{productId}/likes` | O  | 좋아요 등록 (멱등)       |
| DELETE | `/api/v1/products/{productId}/likes` | O  | 좋아요 취소 (멱등)       |
| GET    | `/api/v1/users/likes`                | O  | 내 좋아요 상품 목록 (본인만) |

### 5.4 주문 (고객)

| METHOD | URI                                        | 인증 | 설명                 |
|--------|--------------------------------------------|----|--------------------|
| POST   | `/api/v1/orders`                           | O  | 주문 요청              |
| GET    | `/api/v1/orders?startedAt=...&endedAt=...` | O  | 주문 목록 조회 (기간, 본인만) |
| GET    | `/api/v1/orders/{orderId}`                 | O  | 주문 상세 조회 (본인만)     |

**주문 요청 본문:**

```json
{
  "items": [
    {
      "productId": 1,
      "quantity": 2
    },
    {
      "productId": 3,
      "quantity": 1
    }
  ]
}
```

**주문 목록 조회 파라미터:**

| 파라미터        | 타입            | 필수 | 기본값  | 설명                                                          |
|-------------|---------------|----|------|-------------------------------------------------------------|
| `startedAt` | LocalDateTime | X  | 1달 전 | 조회 시작일시 (>=, inclusive). DefaultTimeZone으로 ZonedDateTime 변환 |
| `endedAt`   | LocalDateTime | X  | 오늘   | 조회 종료일시 (<, exclusive). DefaultTimeZone으로 ZonedDateTime 변환  |
| `page`      | Int           | X  | 0    | 페이지 번호                                                      |
| `size`      | Int           | X  | 20   | 페이지당 항목 수                                                   |

### 5.5 주문 (어드민)

| METHOD | URI                                   | 설명       |
|--------|---------------------------------------|----------|
| GET    | `/api-admin/v1/orders?page=0&size=20` | 주문 목록 조회 |
| GET    | `/api-admin/v1/orders/{orderId}`      | 주문 상세 조회 |

---

## 6. 도메인 규칙 및 제약사항

### 브랜드 (Brand)

- 브랜드명(name)은 필수이다
- 브랜드명에 유니크 제약은 없다 (동명 브랜드 허용)
- 브랜드 삭제 시 소속 상품도 함께 soft delete (cascade)
- 삭제된 브랜드의 상품은 대고객 조회에서 미노출

### 상품 (Product)

- 상품은 반드시 하나의 브랜드에 소속된다 (brandId 필수)
- 상품 등록 시 브랜드가 존재해야 하고, 삭제 상태가 아니어야 한다
- 상품의 브랜드는 등록 이후 변경할 수 없다
- name(상품명): 필수
- price(가격): BigDecimal, 0 이상 (음수 불가)
- stock(재고): Int, 0 이상 (음수 불가), VO로 검증
- status(상태): ON_SALE / SOLD_OUT / HIDDEN
    - stock 차감 → 0이면 자동 `SOLD_OUT`
    - stock 추가 → 0에서 양수이면 자동 `ON_SALE`
    - `HIDDEN`은 어드민이 직접 설정
- likeCount(좋아요 수): Int, 비정규화 필드, 좋아요 등록/취소 시 동기 증감

### 좋아요 (Like)

- BaseEntity를 상속하지 않는다 (id, userId, productId만 보유)
- 취소 시 하드 딜리트(물리 삭제)로 관리한다 (soft delete 미적용)
- 사용자-상품 쌍은 유일하다 (unique constraint: userId + productId)
- 등록/취소 모두 멱등하게 동작한다
- 삭제된 상품에 대한 좋아요는 등록할 수 없다
- 좋아요 등록 시 Product.likeCount 증가, 취소 시 감소
- 좋아요 목록 조회 시 삭제된 상품은 미노출
- 삭제된 상품에 대한 좋아요 취소 시 200 응답 (Like 레코드가 있으면 삭제, 없으면 무시). 상품이 삭제 상태이므로 likeCount는 갱신하지 않는다

### 주문 (Order)

- 주문은 최소 1개 이상의 주문 항목(OrderItem)을 가져야 한다
- 주문 항목의 수량(quantity)은 1 이상이어야 한다
- 주문 항목의 상품은 고유해야 한다 (같은 productId 중복 불가)
- 주문 시 각 상품의 재고를 확인하고 차감한다 (트랜잭션 내)
- 재고가 부족하면 주문 전체가 실패한다 (all-or-nothing, 부분 주문 없음)
- 주문 항목에는 주문 시점의 상품 스냅샷(이름, 가격)이 저장된다
- 주문 상태: CREATED / PAID / CANCELLED / FAILED (현재는 CREATED만 사용)
- 주문의 totalPrice는 주문 생성 시 계산하여 저장한다 (반정규화)
- 주문 목록 조회는 기간 기반 (startedAt ~ endedAt, 기준: createdAt)
    - startedAt: 해당 일시 이상 (>=), endedAt: 해당 일시 미만 (<)
    - 미입력 시 최근 1달
- 사용자는 본인의 주문만 조회 가능

---

## 7. 인증/인가

### 대고객 인증 (기존 시스템)

- `X-Loopers-LoginId` + `X-Loopers-LoginPw` 헤더로 사용자를 식별한다
- 인증이 필요한 API: 좋아요, 주문, 내 정보 조회
- 인증이 불필요한 API: 상품/브랜드 조회 (비로그인 허용)
- 인증 실패 시: 401 응답, "인증에 실패했습니다" (유저 미존재/비밀번호 불일치 구분 안 함)
- 인증 성공 시: AuthInterceptor가 request에 userId를 설정 → `AuthUserArgumentResolver`가 `@AuthUser userId: Long` 파라미터에 주입

### 어드민 인증 (신규)

- `X-Loopers-Ldap: loopers.admin` 헤더로 어드민을 식별한다
- 실제 LDAP 프로토콜 구현이 아닌 헤더 값 단순 비교
- `/api-admin/**` 경로에 인터셉터로 적용
- 인증 실패 시: 401 응답

### 인터셉터 경로 정리

| 경로 패턴                           | 인터셉터                  | 비고      |
|---------------------------------|-----------------------|---------|
| `/api/v1/users/**` (sign-up 제외) | AuthInterceptor       | 기존      |
| `/api/v1/products/*/likes`      | AuthInterceptor       | 신규      |
| `/api/v1/users/likes`           | AuthInterceptor       | 신규      |
| `/api/v1/orders/**`             | AuthInterceptor       | 신규      |
| `/api-admin/**`                 | AdminInterceptor (신규) | 신규      |
| `/api/v1/brands/**`             | 없음                    | 비로그인 허용 |
| `/api/v1/products` (목록/상세)      | 없음                    | 비로그인 허용 |

---

## 8. 기존 시스템과의 관계

### 1주차 완료 (재사용)

- **User 도메인**: 회원가입, 내 정보 조회, 비밀번호 변경
- **AuthInterceptor**: `X-Loopers-LoginId/LoginPw` 헤더 기반 식별
- **AuthService**: 로그인 ID로 사용자 조회 + 비밀번호 검증
- **BaseEntity**: id, createdAt, updatedAt, deletedAt 자동관리, soft delete(delete()/restore())
- **에러 처리**: CoreException, ErrorType(BAD_REQUEST/NOT_FOUND/UNAUTHORIZED/CONFLICT/INTERNAL_ERROR)
- **API 응답**: ApiResponse 래퍼, ApiControllerAdvice 전역 예외 처리
- **Value Object 패턴**: 생성 시점에 VO로 검증, 엔티티 필드는 기본 타입으로 유지

### 2주차 신규 구현

- **Brand 도메인**: 엔티티, 서비스, CRUD API (고객 + 어드민)
- **Product 도메인**: 엔티티 (stock VO, status enum, likeCount), 서비스, CRUD API (고객 + 어드민)
- **Like 도메인**: 엔티티 (userId + productId unique), 서비스, 등록/취소/목록 API
- **Order 도메인**: 엔티티 (Order + OrderItem with snapshot), 서비스, 주문 생성/조회 API
- **AdminInterceptor**: `X-Loopers-Ldap` 헤더 기반 어드민 식별 (신규)
- **인증 경로 확장**: 좋아요, 주문 경로에 AuthInterceptor 추가

### 추후 확장

- 결제 시스템 연동 (OrderStatus 활용)
- 동시성 해결 (Redis Lua 기반 재고 관리)
- 좋아요/재고 캐싱 (Redis)
- 브랜드 트리 구조 (parentId)
- 1인당 구매 수량 제한

---

## 9. 잠재 리스크

| 리스크                | 영향                                                        | 현재 대응                    | 향후 대응                                                                                  |
|--------------------|-----------------------------------------------------------|--------------------------|----------------------------------------------------------------------------------------|
| **주문 트랜잭션 비대화**    | 여러 상품 재고 차감 + 주문 생성 + 스냅샷 저장이 하나의 트랜잭션 → 락 경합             | 현재 스코프에서는 단일 트랜잭션으로 처리   | Redis 재고 선점 + 이벤트 기반 분리                                                                |
| **likeCount 정합성**  | 좋아요 등록/취소 시 Product.likeCount 동기 증감 → 동시 요청 시 정합성 깨질 수 있음 | 단일 트랜잭션 내 처리             | Redis 캐시 또는 비동기 집계                                                                     |
| **브랜드 삭제 연쇄 영향**   | 브랜드 삭제 시 대량 상품 soft delete → 트랜잭션 부하                      | 동기 처리 (상품 수가 적은 초기 단계)   | 배치/비동기 처리                                                                              |
| **주문 목록 기간 조회 성능** | 날짜 범위 검색은 인덱스 전략에 따라 성능 차이 큼                              | createdAt 인덱스 + 기본 1달 제한 | 복합 인덱스 최적화                                                                             |
| **재고 동시 차감**       | 동시 주문 시 재고가 음수로 떨어질 수 있음                                  | 향후 과제로 명시 (현재는 단일 요청 기준) | Atomic SQL UPDATE (`stock = stock - :qty WHERE stock >= :qty`), @Version, 또는 Redis Lua |
| **상품 복구 시 likeCount 불일치** | 삭제된 상품의 좋아요 취소 시 likeCount 미갱신 → 복구 시 실제 likes 수와 불일치 | 현재 상품 복구 시나리오 없음 (scope 외) | 복구 로직에 likeCount 재집계 추가 |

---

## 10. 설계 결정 사항

### soft delete 조회 전략

- Entity에 `@Where(clause = "deleted_at IS NULL")` 어노테이션을 사용하지 않는다
- 대신 Repository 메서드마다 `deletedAt IS NULL` 조건을 명시적으로 추가한다
- 이유: 어드민 API에서 삭제된 데이터도 조회해야 하므로, `@Where`는 유연성을 제한한다

### 트랜잭션 전략

- **Service**: 변경 작업에 `@Transactional` 필수 적용
- **Facade**: 선택적 적용. 여러 Service를 조합하여 원자성이 필요한 경우에만 사용
- 이유: Facade에 무조건 `@Transactional`을 걸면, 외부 API 호출이나 비동기 통신이 트랜잭션에 묶여 DB 커넥션을 오래 점유할 수 있다
- 단일 Service 호출만 하는 Facade 메서드는 Service의 `@Transactional`에 위임한다

### 인증된 사용자 식별

- AuthInterceptor에서 인증 성공 시 `request.setAttribute("userId", user.id)` 설정
- `AuthUserArgumentResolver` (`HandlerMethodArgumentResolver` 구현체)가 `@AuthUser userId: Long` 파라미터에 주입
- 좋아요, 주문 등 인증이 필요한 API에서 활용

### enum 배치 전략

- `ProductStatus`, `OrderStatus`는 각각 `Product`, `Order` 클래스의 inner enum으로 구현한다
- 각 도메인 내부에서만 사용되므로 별도 파일로 분리할 필요가 없다

### 주문 목록 조회 시간대 처리

- 클라이언트가 전달하는 `startedAt`/`endedAt`은 `LocalDateTime`이다
- `CommerceApiApplication`의 `DefaultTimeZone`으로 `ZonedDateTime`으로 변환한다

### 좋아요 취소 시 삭제된 상품 처리

- 삭제된 상품에 대한 좋아요 취소: 200 응답. Like 레코드가 있으면 삭제, 없으면 무시 (멱등)
- 삭제된 상품이므로 likeCount는 갱신하지 않는다

### 동적 쿼리 구현 방식

- 상품 목록 조회의 동적 필터(brandId nullable) + 동적 정렬(ProductSort)은 Querydsl로 구현한다
- Repository 인터페이스의 커스텀 구현체에서 Querydsl을 사용하여 동적 쿼리를 작성한다
