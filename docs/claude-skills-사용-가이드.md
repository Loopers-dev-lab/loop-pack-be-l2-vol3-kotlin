# Claude Skills 사용 가이드 - 설계 문서 자동 생성

## 개요

이 프로젝트에는 새로운 기능 구현 전 필요한 설계 문서를 자동으로 생성하는 4종의 Claude Code 커스텀 스킬이 포함되어 있습니다.
각 스킬은 프로젝트의 기존 패턴(레이어 아키텍처, 네이밍 규칙, API 응답 형식 등)을 자동으로 분석하여 일관된 형식의 문서를 생성합니다.

### Round2 도메인 컨텍스트

Round2에서는 다음 5개 도메인을 다룹니다. 각 도메인은 서로 연관되어 있으며, 스킬 실행 시 도메인 간 의존 관계를 자동으로 반영합니다.

| 도메인 | 설명 | 관련 도메인 |
|--------|------|-------------|
| 유저(Users) | 회원가입, 로그인, 내정보 조회/수정 | - |
| 브랜드(Brands) | 브랜드 CRUD (Admin) | 상품 |
| 상품(Products) | 상품 CRUD (Admin), 상품 조회 (고객) | 브랜드, 좋아요, 주문 |
| 좋아요(Likes) | 상품 좋아요/취소, 좋아요 목록 조회 | 유저, 상품 |
| 주문(Orders) | 주문 생성, 주문 내역 조회 | 유저, 상품, 브랜드 |

### 인증 방식 (Round2)

| 구분 | 인증 헤더 | API Prefix |
|------|----------|------------|
| 대고객 API | `X-Loopers-LoginId` + `X-Loopers-LoginPw` | `/api/v1` |
| 어드민 API | `X-Loopers-Ldap: loopers.admin` | `/api-admin/v1` |

---

## 스킬 목록

| 순서 | 스킬 | 명령어 | 출력 파일 | 역할 |
|------|------|--------|----------|------|
| 1 | 요구사항 | `/requirements {기능명}` | `docs/{기능명}/01-requirements.md` | API 명세, 비즈니스 규칙, 구현 체크리스트, 테스트 시나리오 |
| 2 | 시퀀스 다이어그램 | `/sequence-diagrams {기능명}` | `docs/{기능명}/02-sequence-diagrams.md` | API별 성공/에러 흐름 Mermaid 시퀀스 다이어그램 |
| 3 | 클래스 다이어그램 | `/class-diagram {기능명}` | `docs/{기능명}/03-class-diagram.md` | 레이어별 클래스 구조 Mermaid 클래스 다이어그램 |
| 4 | ERD | `/erd {기능명}` | `docs/{기능명}/04-erd.md` | Mermaid ERD, 테이블 상세 명세, 인덱스 설계 |

---

## API 스펙 참고 문서

각 스킬은 실행 시 해당 기능의 API 스펙 참고 문서를 자동으로 참조합니다. 이 문서들은 요구사항 작성의 기준이 되는 참고 자료입니다.

| 기능명 | 참고 문서 경로 | 설명 |
|--------|---------------|------|
| 유저 | `docs/유저/유저-API-스펙.md` | 회원가입, 내정보 조회, 비밀번호 변경 |
| 브랜드-상품 | `docs/브랜드-상품/브랜드-상품-API-스펙.md` | 브랜드 상세, 상품 목록/상세 조회 (고객용) |
| 브랜드-상품-Admin | `docs/브랜드-상품-Admin/브랜드-상품-Admin-API-스펙.md` | 브랜드/상품 CRUD (어드민용) |
| 좋아요 | `docs/좋아요/좋아요-API-스펙.md` | 좋아요 등록/취소, 좋아요 목록 조회 |
| 주문 | `docs/주문/주문-API-스펙.md` | 주문 생성, 주문 내역/상세 조회 |
| 주문-Admin | `docs/주문-Admin/주문-Admin-API-스펙.md` | 주문 목록/상세 조회 (어드민용) |

공통 참고 문서:
- `docs/공통/API-제안-사항.md`: API prefix 규칙, 인증 방식, 응답 형식, 에러 코드
- `docs/공통/서비스-흐름-예시.md`: 전체 서비스 흐름 (회원가입 -> 상품 탐색 -> 좋아요 -> 주문)

---

## 권장 실행 순서

설계 문서는 다음 순서대로 생성하는 것을 권장합니다.
시퀀스 다이어그램, 클래스 다이어그램, ERD는 요구사항 문서를 기반으로 작성되기 때문에 **반드시 요구사항 문서를 먼저 생성**해야 합니다.

```
/requirements {기능명}       <- 1단계: 요구사항 정의 (필수 선행)
    |
/sequence-diagrams {기능명}  <- 2단계: 동작 흐름 설계
    |
/class-diagram {기능명}      <- 3단계: 클래스 구조 설계
    |
/erd {기능명}                <- 4단계: 데이터베이스 설계
```

2~4단계는 서로 독립적이므로 필요에 따라 순서를 변경하거나 선택적으로 실행할 수 있습니다.
단, 모든 스킬은 `01-requirements.md` 파일의 존재를 전제조건으로 확인합니다.

---

## 사용법 상세

### 1. `/requirements` - 요구사항 문서 생성

```
/requirements 상품 관리
```

**동작:**
1. `CLAUDE.md`, `docs/공통/API-제안-사항.md`, `docs/공통/서비스-흐름-예시.md`, 해당 기능의 API 스펙 참고 문서를 분석하여 Round2 도메인 컨텍스트를 파악합니다.
2. 사용자에게 질문하여 유스케이스, API 엔드포인트, 인증 여부, 관련 도메인과의 의존 관계를 확인합니다.
3. 유저 중심 서술 원칙("유저가 ~한다" 형태)에 따라 Part 1~7 구조의 요구사항 문서를 생성합니다.
4. 품질 체크리스트를 자가 검증한 결과를 문서 하단에 포함합니다.
5. 생성된 문서를 보여주고 검토를 요청합니다.

**생성되는 문서 구조:**
- 개요 및 관련 도메인
- Part 1: API 명세 (Endpoint, Request, Response)
- Part 2: 비즈니스 규칙
- Part 3: 구현 컴포넌트 (레이어별 구조, 처리 흐름)
- Part 4: 구현 체크리스트 (Phase별 TDD용)
- Part 5: 테스트 시나리오
- Part 6: 보안 고려사항
- Part 7: 검증 명령어
- 품질 체크리스트 (자가 검증 결과)

**핵심 원칙:**
- **유저 중심 서술**: "유저가 상품에 좋아요를 누르면, 좋아요 수가 증가한다" 형태로 기능을 서술
- **도메인 간 관계 명시**: 해당 기능이 의존하는 다른 도메인(유저, 브랜드, 상품, 좋아요, 주문)을 명확히 기술

### 2. `/sequence-diagrams` - 시퀀스 다이어그램 생성

```
/sequence-diagrams 상품 관리
```

**전제조건:** `docs/상품-관리/01-requirements.md`가 존재해야 합니다.

**동작:**
1. 요구사항 문서와 해당 기능의 API 스펙 참고 문서에서 API 엔드포인트와 처리 흐름을 파악합니다.
2. 실제 소스 코드에서 클래스명과 메서드명을 확인합니다.
3. 각 API별로 성공 흐름과 에러 흐름의 Mermaid 시퀀스 다이어그램을 작성합니다.
4. 품질 체크리스트를 자가 검증한 결과를 문서 하단에 포함합니다.

**다이어그램 특징:**
- `autonumber`로 단계 번호 자동 부여
- participant에 실제 클래스명 사용 (예: `participant Controller as ProductV1Controller`)
- 대고객 API는 `HeaderAuthFilter`, 어드민 API는 `LdapAuthFilter`를 인증 participant로 포함
- 메서드명과 파라미터 명시
- `alt`/`else` 블록으로 에러 분기 표현

**핵심 원칙:**
- **책임 객체(Responsibility Object) 원칙**: 각 participant가 수행하는 핵심 로직(검증, 변환, 조회, 저장)을 메서드명으로 명확히 표현
- **도메인 간 분리**: 여러 도메인이 관련된 경우(예: 주문 시 ProductService로 재고 확인), 각 도메인의 Service를 별도 participant로 분리하여 책임 경계를 표현

### 3. `/class-diagram` - 클래스 다이어그램 생성

```
/class-diagram 상품 관리
```

**전제조건:** `docs/상품-관리/01-requirements.md`가 존재해야 합니다.

**동작:**
1. 요구사항 문서와 해당 기능의 API 스펙 참고 문서에서 구현 컴포넌트를 파악합니다.
2. 기존 코드베이스에서 네이밍 규칙과 클래스 설계 패턴을 분석합니다.
3. 레이어별(Domain, Application, Interfaces, Infrastructure) Mermaid 클래스 다이어그램을 작성합니다.
4. 품질 체크리스트를 자가 검증한 결과를 문서 하단에 포함합니다.

**다이어그램 구성:**
- 전체 레이어 관계 다이어그램
- Domain 레이어 상세 (Entity + BaseEntity 상속, Repository, Service)
- Application 레이어 상세 (Facade, Info DTO)
- Interfaces 레이어 상세 (Controller, ApiSpec, DTO)
- Infrastructure 레이어 상세 (RepositoryImpl, JpaRepository)

**핵심 원칙:**
- **도메인 설계 표현**: 도메인 모델(Model)에 비즈니스 로직과 검증 메서드를 포함하여, 빈약한 도메인 모델(Anemic Domain Model)을 지양
- **도메인 간 참조**: 여러 도메인이 관련된 경우 참조 관계를 명확히 표현
- **Facade 의존성**: Facade가 여러 도메인 Service를 조합하는 경우, 각 Service 의존성을 모두 표현

### 4. `/erd` - ERD 생성

```
/erd 상품 관리
```

**전제조건:** `docs/상품-관리/01-requirements.md`가 존재해야 합니다.

**동작:**
1. 요구사항 문서와 해당 기능의 API 스펙 참고 문서에서 도메인 모델과 필드 정보를 파악합니다.
2. 기존 Entity 클래스(MemberModel 등)와 BaseEntity를 분석합니다.
3. Mermaid ERD, 테이블 상세 명세, 인덱스 설계를 포함한 문서를 작성합니다.
4. 품질 체크리스트를 자가 검증한 결과를 문서 하단에 포함합니다.

**문서 구성:**
- Mermaid erDiagram (기존 테이블 + 신규 테이블)
- 테이블별 컬럼 상세 (타입, Nullable, 제약조건, 설명)
- 테이블간 관계 설명
- 인덱스 설계

**핵심 원칙:**
- **데이터 정합성**: FK 제약 조건으로 참조 무결성 보장 (존재하지 않는 브랜드/상품/유저 참조 방지)
- **삭제 정책**: 연쇄 삭제(CASCADE) 또는 소프트 삭제 정책을 비즈니스 규칙에 맞게 결정
- **중복 방지**: UNIQUE 제약 조건으로 데이터 중복 방지 (예: 유저+상품 좋아요 중복 불가)
- **스냅샷 구분**: 스냅샷 데이터(주문 시 상품 정보)와 참조 데이터의 구분을 명확히

---

## 품질 체크리스트

모든 스킬은 문서 생성 후 자동으로 품질 체크리스트를 자가 검증하여 결과를 문서 하단에 포함합니다.

### `/requirements` 품질 체크리스트
- 상품/브랜드/좋아요/주문 등 관련 도메인과의 관계가 명시되어 있는가?
- 기능 요구사항이 유저 중심("유저가 ~한다")으로 서술되어 있는가?
- 인증 방식(헤더 기반)이 정확히 명시되어 있는가?
- 에러 케이스와 예외 상황이 포함되어 있는가?
- Phase별 구현 체크리스트가 TDD 워크플로우에 맞게 구성되어 있는가?

### `/sequence-diagrams` 품질 체크리스트
- 각 participant의 책임(검증, 변환, 조회, 저장 등)이 메서드명으로 명확히 드러나는가?
- 여러 도메인이 관련된 경우, 각 도메인의 Service가 별도 participant로 분리되어 있는가?
- 인증 방식(헤더 기반)이 다이어그램에 정확히 반영되어 있는가?
- 성공 흐름과 에러 흐름이 모두 포함되어 있는가?
- 에러 시나리오 테이블에 발생 시점과 책임 객체가 명시되어 있는가?

### `/class-diagram` 품질 체크리스트
- 도메인 모델(Model)에 비즈니스 로직과 검증 메서드가 포함되어 있는가? (빈약한 도메인 모델 지양)
- 여러 도메인이 관련된 경우, 도메인 간 참조 관계가 명확히 표현되어 있는가?
- Facade가 조합하는 여러 Service 의존성이 모두 표현되어 있는가?
- 각 레이어(Domain, Application, Interfaces, Infrastructure)의 클래스가 모두 포함되어 있는가?
- 클래스 간 관계(상속, 구현, 의존, 컴포지션)가 정확히 표현되어 있는가?

### `/erd` 품질 체크리스트
- FK 제약 조건으로 참조 무결성이 보장되는가? (존재하지 않는 브랜드/상품/유저 참조 방지)
- 연쇄 삭제 또는 소프트 삭제 정책이 비즈니스 규칙과 일치하는가? (예: 브랜드 삭제 시 상품 처리)
- UNIQUE 제약 조건으로 데이터 중복이 방지되는가? (예: 유저+상품 좋아요 중복 방지)
- 스냅샷 데이터와 참조 데이터가 구분되어 있는가? (예: 주문 시 상품 정보 스냅샷)
- 조회 성능을 위한 인덱스가 적절히 설계되어 있는가?

---

## 전체 워크플로우 예시: "좋아요" 기능

### Step 1: 요구사항 정의

```
/requirements 좋아요
```

Claude가 `docs/좋아요/좋아요-API-스펙.md`를 참조하고 사용자에게 질문합니다:
- 좋아요의 핵심 유스케이스는 무엇인가요? (좋아요 등록, 취소, 목록 조회)
- 어떤 API 엔드포인트가 필요한가요?
- 인증이 필요한 API는 어떤 것인가요? (대고객: `X-Loopers-LoginId/LoginPw` 헤더)
- 관련 도메인과의 의존 관계는? (유저, 상품 도메인과 연관)

사용자 응답을 바탕으로 `docs/좋아요/01-requirements.md`가 생성됩니다.

### Step 2: 시퀀스 다이어그램 작성

```
/sequence-diagrams 좋아요
```

요구사항 문서에 정의된 API별로 성공/에러 흐름 시퀀스 다이어그램이 포함된
`docs/좋아요/02-sequence-diagrams.md`가 생성됩니다.
HeaderAuthFilter를 통한 인증 흐름, LikeService와 ProductService 간 책임 분리가 표현됩니다.

### Step 3: 클래스 다이어그램 작성

```
/class-diagram 좋아요
```

레이어별 클래스 구조가 포함된
`docs/좋아요/03-class-diagram.md`가 생성됩니다.
LikeModel에 비즈니스 로직이 포함되고, ProductService와의 의존 관계가 표현됩니다.

### Step 4: ERD 작성

```
/erd 좋아요
```

like 테이블과 기존 member, product 테이블과의 관계가 포함된
`docs/좋아요/04-erd.md`가 생성됩니다.
유저+상품 UNIQUE 제약 조건, FK 참조 무결성이 포함됩니다.

### Step 5: TDD 구현으로 전환

설계 문서가 모두 완성되면, 요구사항 문서의 **Part 4: 구현 체크리스트**를 기준으로 TDD 워크플로우를 시작합니다:

```
docs/좋아요/01-requirements.md의 Phase 1부터 TDD 방식으로 구현해주세요.
```

각 Phase마다:
1. **RED**: 해당 Phase의 테스트 코드 먼저 작성 (실패 확인)
2. **GREEN**: 테스트 통과하는 최소 구현
3. **REFACTOR**: 코드 정리 및 품질 개선
4. **검토 요청**: 작업 결과 보고 및 사용자 승인 대기

---

## 문서 디렉토리 구조

```
docs/
├── 공통/
│   ├── API-제안-사항.md              <- API prefix, 인증 방식, 응답 형식
│   └── 서비스-흐름-예시.md            <- 전체 서비스 흐름 예시
├── 유저/
│   ├── 유저-API-스펙.md              <- API 스펙 참고 문서
│   └── 01-requirements.md           <- 요구사항 문서 (스킬로 생성)
├── 브랜드-상품/
│   ├── 브랜드-상품-API-스펙.md        <- API 스펙 참고 문서
│   └── 01-requirements.md
├── 브랜드-상품-Admin/
│   ├── 브랜드-상품-Admin-API-스펙.md  <- API 스펙 참고 문서
│   └── 01-requirements.md
├── 좋아요/
│   ├── 좋아요-API-스펙.md             <- API 스펙 참고 문서
│   └── 01-requirements.md
├── 주문/
│   ├── 주문-API-스펙.md              <- API 스펙 참고 문서
│   └── 01-requirements.md
├── 주문-Admin/
│   ├── 주문-Admin-API-스펙.md        <- API 스펙 참고 문서
│   └── 01-requirements.md
└── claude-skills-사용-가이드.md       <- 이 가이드
```

스킬 실행 후 생성되는 설계 문서는 각 기능 디렉토리에 추가됩니다:
```
docs/좋아요/
├── 좋아요-API-스펙.md              <- 참고 문서 (수동 작성)
├── 01-requirements.md             <- /requirements 좋아요
├── 02-sequence-diagrams.md        <- /sequence-diagrams 좋아요
├── 03-class-diagram.md            <- /class-diagram 좋아요
└── 04-erd.md                      <- /erd 좋아요
```

---

## 주의사항

1. **순서 준수**: 요구사항 문서(`01-requirements.md`)를 반드시 먼저 생성해야 합니다. 나머지 스킬은 이 문서의 존재를 전제조건으로 확인하며, 없으면 안내 후 중단합니다.

2. **기능명 통일**: 4개 스킬에 전달하는 기능명은 동일해야 합니다. 예를 들어, `/requirements 좋아요`로 시작했으면 이후에도 `좋아요`를 사용해야 합니다. 기능명은 출력 디렉토리 경로에 사용됩니다.

3. **API 스펙 참고 문서**: 각 스킬은 기능명에 매핑된 API 스펙 참고 문서를 자동으로 참조합니다. 참고 문서가 없는 기능을 추가하려면 먼저 해당 기능의 API 스펙 참고 문서를 작성해야 합니다.

4. **검토 후 진행**: 각 스킬은 문서 생성 후 사용자 검토를 요청합니다. 검토 및 수정이 완료된 후에 다음 스킬을 실행하는 것을 권장합니다.

5. **품질 체크리스트 자가 검증**: 모든 스킬은 문서 완성 후 해당 스킬의 품질 체크리스트를 스스로 검증하여 결과를 문서 하단에 포함합니다. 검증 항목이 미충족인 경우 수정이 필요합니다.

6. **덮어쓰기 방지**: 동일한 경로에 이미 파일이 존재하면, 스킬이 사용자에게 덮어쓸지 확인합니다. 의도치 않은 덮어쓰기를 방지합니다.

7. **기존 코드 반영**: 모든 스킬은 실행 시 실제 소스 코드를 읽어 클래스명, 패키지 구조, 네이밍 규칙을 반영합니다. 코드 변경 후 다시 실행하면 최신 상태가 반영됩니다.

8. **한국어 출력**: 생성되는 모든 문서는 한국어로 작성됩니다. Mermaid 다이어그램 내 participant 별칭과 메서드명은 실제 코드의 영문명을 사용합니다.
